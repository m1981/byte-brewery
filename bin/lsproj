#!/usr/bin/env python3
"""
lsproj
Simple Project File Lister.
Reads whitelist patterns from .projlist and excludes files based on .gitignore.
"""

import sys
import os
import fnmatch
import argparse
from pathlib import Path
from typing import List

# Import the shared parser
try:
    from ignore_utils import GitignoreParser
except ImportError:
    print("Error: ignore_utils.py not found. Please ensure it is in the same directory.", file=sys.stderr)
    sys.exit(1)

CONFIG_FILE = ".projlist"


def load_whitelist(project_dir: Path) -> List[str]:
    """Load whitelist patterns from config file."""
    config_path = project_dir / CONFIG_FILE
    patterns = []

    if not config_path.exists():
        print(f"Error: Config file '{CONFIG_FILE}' not found in {project_dir}", file=sys.stderr)
        print("Please create a .projlist file with patterns like:", file=sys.stderr)
        print("*.ts\n*.py", file=sys.stderr)
        sys.exit(1)

    with open(config_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#'):
                patterns.append(line)
    return patterns


def matches_whitelist(filename: str, patterns: List[str]) -> bool:
    """Check if filename matches any whitelist pattern."""
    for pattern in patterns:
        if fnmatch.fnmatch(filename, pattern):
            return True
    return False


def main():
    parser = argparse.ArgumentParser(
        description="Lists project files based on .projlist whitelist and .gitignore rules."
    )
    parser.add_argument("root_dir", nargs='?', default='.', help="Root directory to scan (default: current).")
    parser.add_argument("-o", "--output", help="Output file path. Defaults to stdout.")

    args = parser.parse_args()

    root_dir = Path(args.root_dir)

    if not root_dir.exists():
        print(f"Error: Directory {root_dir} does not exist.", file=sys.stderr)
        sys.exit(1)

    ignore_parser = GitignoreParser(root_dir)
    whitelist = load_whitelist(root_dir)

    # Prepare output stream
    output_stream = sys.stdout
    if args.output:
        try:
            output_stream = open(args.output, 'w', encoding='utf-8')
        except IOError as e:
            print(f"Error opening output file: {e}", file=sys.stderr)
            sys.exit(1)

    try:
        # Walk the directory tree
        for root, dirs, files in os.walk(root_dir):
            # 1. Prune directories in-place based on ignore rules
            for i in range(len(dirs) - 1, -1, -1):
                dir_path = Path(root) / dirs[i]
                if ignore_parser.should_ignore(dir_path):
                    del dirs[i]

            # 2. Process files
            for file in files:
                file_path = Path(root) / file

                # Skip if ignored
                if ignore_parser.should_ignore(file_path):
                    continue

                # Check whitelist
                if matches_whitelist(file, whitelist):
                    # Print relative path for clean output
                    print(os.path.relpath(file_path, root_dir), file=output_stream)
    finally:
        if args.output and output_stream is not sys.stdout:
            output_stream.close()


if __name__ == "__main__":
    main()